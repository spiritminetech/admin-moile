import Quotation from './models/QuotationModel.js';
import QuotationApproval from './models/QuotationApprovalModel.js';
import Client from '../client/ClientModel.js';
import Company from '../company/CompanyModel.js';
import Project from '../project/models/ProjectModel.js';

// Generate quotation code
const generateQuotationCode = async (companyId) => {
  const count = await Quotation.countDocuments({ companyId });
  return `QT-${String(count + 1).padStart(3, '0')}`;
};

// GET /api/quotations - List quotations with filters
export const getQuotations = async (req, res) => {
  try {
    const { 
      companyId, 
      clientId, 
      status, 
      page = 1, 
      limit = 20,
      startDate,
      endDate 
    } = req.query;

    const filter = {};
    
    if (companyId) filter.companyId = parseInt(companyId);
    if (clientId) filter.clientId = parseInt(clientId);
    if (status) filter.status = status;
    
    if (startDate || endDate) {
      filter.createdAt = {};
      if (startDate) filter.createdAt.$gte = new Date(startDate);
      if (endDate) filter.createdAt.$lte = new Date(endDate);
    }

    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    const quotations = await Quotation.find(filter)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit))
      .lean();

    // Get client and company names
    const enrichedQuotations = await Promise.all(
      quotations.map(async (quotation) => {
        const [client, company] = await Promise.all([
          Client.findOne({ id: quotation.clientId }).select('name'),
          Company.findOne({ id: quotation.companyId }).select('name')
        ]);

        return {
          ...quotation,
          clientName: client?.name || 'Unknown Client',
          companyName: company?.name || 'Unknown Company'
        };
      })
    );

    const total = await Quotation.countDocuments(filter);

    res.json({
      success: true,
      data: enrichedQuotations,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit))
      }
    });
  } catch (error) {
    console.error('Error fetching quotations:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch quotations',
      error: error.message
    });
  }
};

// GET /api/quotations/:id - Get single quotation
export const getQuotationById = async (req, res) => {
  try {
    const { id } = req.params;
    
    const quotation = await Quotation.findOne({ id: parseInt(id) }).lean();
    
    if (!quotation) {
      return res.status(404).json({
        success: false,
        message: 'Quotation not found'
      });
    }

    // Get client and company details
    const [client, company] = await Promise.all([
      Client.findOne({ id: quotation.clientId }).select('name email phone'),
      Company.findOne({ id: quotation.companyId }).select('name address')
    ]);

    const enrichedQuotation = {
      ...quotation,
      client: client || null,
      company: company || null
    };

    res.json({
      success: true,
      data: enrichedQuotation
    });
  } catch (error) {
    console.error('Error fetching quotation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch quotation',
      error: error.message
    });
  }
};

// POST /api/quotations - Create new quotation
export const createQuotation = async (req, res) => {
  try {
    const {
      companyId,
      clientId,
      projectName,
      description,
      validUntil
    } = req.body;

    // Validate required fields
    if (!companyId || !clientId || !projectName) {
      return res.status(400).json({
        success: false,
        message: 'Company ID, Client ID, and Project Name are required'
      });
    }

    // Verify client and company exist
    const [client, company] = await Promise.all([
      Client.findOne({ id: clientId }),
      Company.findOne({ id: companyId })
    ]);

    if (!client) {
      return res.status(400).json({
        success: false,
        message: 'Client not found'
      });
    }

    if (!company) {
      return res.status(400).json({
        success: false,
        message: 'Company not found'
      });
    }

    // Create quotation (ID and quotationCode will be auto-generated by pre-save hook)
    const quotation = new Quotation({
      companyId: parseInt(companyId),
      clientId: parseInt(clientId),
      projectName,
      description,
      validUntil: validUntil ? new Date(validUntil) : null,
      createdBy: req.user?.userId || null
    });

    await quotation.save();

    res.status(201).json({
      success: true,
      message: 'Quotation created successfully',
      data: quotation
    });
  } catch (error) {
    console.error('Error creating quotation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create quotation',
      error: error.message
    });
  }
};

// PUT /api/quotations/:id - Update quotation
export const updateQuotation = async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    // Don't allow updating certain fields
    delete updateData.quotationCode;
    delete updateData.version;
    delete updateData.createdBy;
    delete updateData.createdAt;
    delete updateData.id; // Don't allow updating the numeric ID

    const quotation = await Quotation.findOneAndUpdate(
      { id: parseInt(id) },
      updateData,
      { new: true, runValidators: true }
    );

    if (!quotation) {
      return res.status(404).json({
        success: false,
        message: 'Quotation not found'
      });
    }

    res.json({
      success: true,
      message: 'Quotation updated successfully',
      data: quotation
    });
  } catch (error) {
    console.error('Error updating quotation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update quotation',
      error: error.message
    });
  }
};

// POST /api/quotations/:id/clone - Clone quotation (new version)
export const cloneQuotation = async (req, res) => {
  try {
    const { id } = req.params;
    
    const originalQuotation = await Quotation.findOne({ id: parseInt(id) });
    
    if (!originalQuotation) {
      return res.status(404).json({
        success: false,
        message: 'Quotation not found'
      });
    }

    // Create new quotation object without MongoDB-specific fields
    const quotationData = originalQuotation.toObject();
    
    // Remove fields that should not be cloned
    delete quotationData._id;
    delete quotationData.id;
    delete quotationData.quotationCode;
    delete quotationData.createdAt;
    delete quotationData.updatedAt;
    delete quotationData.__v;
    delete quotationData.approvedBy;
    delete quotationData.approvedAt;
    delete quotationData.projectId;

    // Set new quotation properties
    quotationData.version = originalQuotation.version + 1;
    quotationData.status = 'Draft';
    quotationData.createdBy = req.user?.userId || originalQuotation.createdBy;
    quotationData.remarks = undefined;

    // Create new quotation (ID and quotationCode will be auto-generated)
    const clonedQuotation = new Quotation(quotationData);
    await clonedQuotation.save();

    res.status(201).json({
      success: true,
      message: 'Quotation cloned successfully',
      data: clonedQuotation
    });
  } catch (error) {
    console.error('Error cloning quotation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to clone quotation',
      error: error.message
    });
  }
};

// POST /api/quotations/:id/submit - Submit quotation for approval
export const submitQuotation = async (req, res) => {
  try {
    const { id } = req.params;
    
    const quotation = await Quotation.findOne({ id: parseInt(id) });
    
    if (!quotation) {
      return res.status(404).json({
        success: false,
        message: 'Quotation not found'
      });
    }

    if (quotation.status !== 'Draft') {
      return res.status(400).json({
        success: false,
        message: 'Only draft quotations can be submitted'
      });
    }

    quotation.status = 'Submitted';
    await quotation.save();

    res.json({
      success: true,
      message: 'Quotation submitted successfully',
      data: quotation
    });
  } catch (error) {
    console.error('Error submitting quotation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to submit quotation',
      error: error.message
    });
  }
};

// POST /api/quotations/:id/approve - Approve quotation
export const approveQuotation = async (req, res) => {
  try {
    const { id } = req.params;
    const { remarks } = req.body;
    
    const quotation = await Quotation.findOne({ id: parseInt(id) });
    
    if (!quotation) {
      return res.status(404).json({
        success: false,
        message: 'Quotation not found'
      });
    }

    // Temporarily allow approval from any status for testing
    // if (quotation.status !== 'Submitted' && quotation.status !== 'Draft') {
    //   console.log(`Approval failed - Quotation ID: ${id}, Current Status: "${quotation.status}", Expected: "Submitted" or "Draft"`);
    //   return res.status(400).json({
    //     success: false,
    //     message: `Cannot approve quotation with status: "${quotation.status}". Only submitted or draft quotations can be approved`
    //   });
    // }

    // Update quotation status
    quotation.status = 'Approved';
    quotation.approvedBy = req.user?.userId || null;
    quotation.approvedAt = new Date();
    if (remarks) quotation.remarks = remarks;

    await quotation.save();

    // Create approval record
    const approval = new QuotationApproval({
      quotationId: quotation.id,
      version: quotation.version,
      approverId: req.user?.userId || null,
      approverRole: req.user?.role || 'Admin',
      action: 'Approved',
      remarks: remarks || '',
      actionAt: new Date()
    });

    await approval.save();

    res.json({
      success: true,
      message: 'Quotation approved successfully',
      data: quotation
    });
  } catch (error) {
    console.error('Error approving quotation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to approve quotation',
      error: error.message
    });
  }
};

// POST /api/quotations/:id/reject - Reject quotation
export const rejectQuotation = async (req, res) => {
  try {
    const { id } = req.params;
    const { remarks } = req.body;
    
    const quotation = await Quotation.findOne({ id: parseInt(id) });
    
    if (!quotation) {
      return res.status(404).json({
        success: false,
        message: 'Quotation not found'
      });
    }

    if (quotation.status !== 'Submitted') {
      return res.status(400).json({
        success: false,
        message: 'Only submitted quotations can be rejected'
      });
    }

    // Update quotation status
    quotation.status = 'Rejected';
    quotation.approvedBy = req.user?.userId || null;
    quotation.approvedAt = new Date();
    if (remarks) quotation.remarks = remarks;

    await quotation.save();

    // Create approval record
    const approval = new QuotationApproval({
      quotationId: quotation.id,
      version: quotation.version,
      approverId: req.user?.userId || null,
      approverRole: req.user?.role || 'Unknown',
      action: 'Rejected',
      remarks: remarks || '',
      actionAt: new Date()
    });

    await approval.save();

    res.json({
      success: true,
      message: 'Quotation rejected',
      data: quotation
    });
  } catch (error) {
    console.error('Error rejecting quotation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to reject quotation',
      error: error.message
    });
  }
};

// POST /api/quotations/:id/convert - Convert to project
export const convertToProject = async (req, res) => {
  try {
    const { id } = req.params;
    
    const quotation = await Quotation.findOne({ id: parseInt(id) });
    
    if (!quotation) {
      return res.status(404).json({
        success: false,
        message: 'Quotation not found'
      });
    }

    if (quotation.status !== 'Approved') {
      return res.status(400).json({
        success: false,
        message: 'Only approved quotations can be converted to projects'
      });
    }

    // Check if already converted
    const existingProject = await Project.findOne({ quotationId: quotation.id });
    if (existingProject) {
      return res.status(400).json({
        success: false,
        message: 'This quotation has already been converted to a project',
        projectId: existingProject.id
      });
    }

    // Generate project code
    const projectCount = await Project.countDocuments({ companyId: quotation.companyId });
    const projectCode = `PRJ-${String(projectCount + 1).padStart(4, '0')}`;

    // Create project from quotation
    const project = new Project({
      projectCode,
      projectName: quotation.projectName,
      companyId: quotation.companyId,
      clientId: quotation.clientId,
      quotationId: quotation.id, // Use numeric ID
      description: quotation.description,
      status: 'Not Started',
      // Auto-populate budget from quotation (READ-ONLY)
      budgetLabor: quotation.totalManpowerCost,
      budgetMaterials: quotation.totalMaterialCost,
      budgetTools: quotation.totalToolCost,
      budgetTransport: quotation.totalTransportCost,
      budgetWarranty: quotation.totalWarrantyCost,
      budgetCertification: quotation.totalCertificationCost,
      createdBy: req.user?.userId || quotation.createdBy
    });

    await project.save();

    // Update quotation status
    quotation.status = 'Converted';
    quotation.projectId = project.id;
    await quotation.save();

    res.json({
      success: true,
      message: 'Quotation converted to project successfully',
      data: {
        quotation,
        project: {
          id: project.id,
          projectCode: project.projectCode,
          projectName: project.projectName
        }
      }
    });
  } catch (error) {
    console.error('Error converting quotation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to convert quotation',
      error: error.message
    });
  }
};

// GET /api/quotations/:id/approvals - Get approval history
export const getApprovalHistory = async (req, res) => {
  try {
    const { id } = req.params;
    
    // Validate ID parameter
    const quotationId = parseInt(id);
    if (isNaN(quotationId)) {
      return res.status(400).json({
        success: false,
        message: `Invalid quotation ID: ${id}`
      });
    }
    
    const approvals = await QuotationApproval.find({ quotationId })
      .sort({ actionAt: -1 })
      .lean();

    res.json({
      success: true,
      data: approvals
    });
  } catch (error) {
    console.error('Error fetching approval history:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch approval history',
      error: error.message
    });
  }
};

// DELETE /api/quotations/:id - Delete quotation
export const deleteQuotation = async (req, res) => {
  try {
    const { id } = req.params;
    
    const quotation = await Quotation.findOne({ id: parseInt(id) });
    
    if (!quotation) {
      return res.status(404).json({
        success: false,
        message: 'Quotation not found'
      });
    }

    // Only allow deletion of draft quotations
    if (quotation.status !== 'Draft') {
      return res.status(400).json({
        success: false,
        message: 'Only draft quotations can be deleted'
      });
    }

    await Quotation.findOneAndDelete({ id: parseInt(id) });

    res.json({
      success: true,
      message: 'Quotation deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting quotation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete quotation',
      error: error.message
    });
  }
};